
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JezzBall Fixed</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const img = new Image();
img.src = "photo.jpg";

const gridSize = 10;
const cols = Math.floor(canvas.width / gridSize);
const rows = Math.floor(canvas.height / gridSize);
let map = Array(rows).fill(0).map(() => Array(cols).fill(0));

for (let x = 0; x < cols; x++) {
  map[0][x] = 1;
  map[rows - 1][x] = 1;
}
for (let y = 0; y < rows; y++) {
  map[y][0] = 1;
  map[y][cols - 1] = 1;
}

let player = { x: Math.floor(cols / 2), y: Math.floor(rows / 2), trail: [], drawing: false, moveTick: 0 };
let dir = null;

const enemies = [
  { x: 200, y: 150, vx: 2, vy: 3, r: 6 },
  { x: 500, y: 100, vx: -3, vy: 2, r: 6 },
];

document.addEventListener("keydown", (e) => {
  if (e.key === "ArrowUp") dir = "up";
  if (e.key === "ArrowDown") dir = "down";
  if (e.key === "ArrowLeft") dir = "left";
  if (e.key === "ArrowRight") dir = "right";
});

function updatePlayer() {
  if (++player.moveTick % 2 !== 0) return;
  if (!dir) return;
  let nx = player.x;
  let ny = player.y;

  if (dir === "up") ny--;
  if (dir === "down") ny++;
  if (dir === "left") nx--;
  if (dir === "right") nx++;

  if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) return;

  if (map[ny][nx] === 0 && !player.drawing) {
    player.drawing = true;
    player.trail = [];
  }

  player.x = nx;
  player.y = ny;

  if (player.drawing) {
    player.trail.push({ x: nx, y: ny });
    if (map[ny][nx] === 1) {
      fillZone();
      player.drawing = false;
      player.trail = [];
    }
  }
}

function fillZone() {
  const visited = Array(rows).fill(0).map(() => Array(cols).fill(false));

  function flood(x, y) {
    const stack = [{ x, y }];
    while (stack.length) {
      const { x, y } = stack.pop();
      if (x < 0 || y < 0 || x >= cols || y >= rows) continue;
      if (visited[y][x] || map[y][x] === 1) continue;
      visited[y][x] = true;
      stack.push({ x: x+1, y });
      stack.push({ x: x-1, y });
      stack.push({ x, y: y+1 });
      stack.push({ x, y: y-1 });
    }
  }

  // заливаємо з 4х країв
  flood(0, 0);
  flood(cols - 1, 0);
  flood(0, rows - 1);
  flood(cols - 1, rows - 1);

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (!visited[y][x]) map[y][x] = 1;
    }
  }
}

function updateEnemies() {
  for (let e of enemies) {
    let gx = Math.floor(e.x / gridSize);
    let gy = Math.floor(e.y / gridSize);
    if (gx >= 0 && gy >= 0 && gx < cols && gy < rows && map[gy][gx] === 1) {
      e.vx *= -1;
      e.vy *= -1;
    }

    e.x += e.vx;
    e.y += e.vy;

    if (e.x < e.r || e.x > canvas.width - e.r) e.vx *= -1;
    if (e.y < e.r || e.y > canvas.height - e.r) e.vy *= -1;
  }
}

function checkCollision() {
  if (!player.drawing) return;
  for (let e of enemies) {
    for (let p of player.trail) {
      const px = p.x * gridSize + gridSize / 2;
      const py = p.y * gridSize + gridSize / 2;
      if (Math.hypot(e.x - px, e.y - py) < e.r + gridSize / 2) {
        alert("Game Over!");
        location.reload();
      }
    }
  }
}

function draw() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (map[y][x] === 1) {
        ctx.drawImage(img, x * gridSize, y * gridSize, gridSize, gridSize, x * gridSize, y * gridSize, gridSize, gridSize);
      }
    }
  }

  // Trail
  if (player.trail.length > 0) {
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(player.trail[0].x * gridSize + gridSize / 2, player.trail[0].y * gridSize + gridSize / 2);
    for (let i = 1; i < player.trail.length; i++) {
      const p = player.trail[i];
      ctx.lineTo(p.x * gridSize + gridSize / 2, p.y * gridSize + gridSize / 2);
    }
    ctx.stroke();
  }

  // Enemies
  ctx.fillStyle = "red";
  for (let e of enemies) {
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
    ctx.fill();
  }

  // Player
  ctx.fillStyle = "lime";
  ctx.beginPath();
  ctx.arc(player.x * gridSize + gridSize / 2, player.y * gridSize + gridSize / 2, 5, 0, Math.PI * 2);
  ctx.fill();
}

function loop() {
  updatePlayer();
  updateEnemies();
  checkCollision();
  draw();
  requestAnimationFrame(loop);
}

img.onload = () => loop();
</script>
</body>
</html>
