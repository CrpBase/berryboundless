
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Photo Cutter 2.0</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; background: #111; }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const img = new Image();
img.src = "photo.jpg";

const gridSize = 20;
const cols = Math.ceil(canvas.width / gridSize);
const rows = Math.ceil(canvas.height / gridSize);
const revealed = Array(rows).fill().map(() => Array(cols).fill(false));

let player = { x: 0, y: 0, dir: null, startX: 0, startY: 0, drawing: false };
let enemies = [
  { x: 100, y: 100, vx: 3, vy: 2, r: 8 },
  { x: 300, y: 150, vx: -2, vy: 3, r: 8 }
];

document.addEventListener("keydown", e => {
  if (e.key.startsWith("Arrow")) {
    if (!player.drawing) {
      player.startX = player.x;
      player.startY = player.y;
      player.drawing = true;
    }
    if (e.key === "ArrowUp") player.dir = "up";
    if (e.key === "ArrowDown") player.dir = "down";
    if (e.key === "ArrowLeft") player.dir = "left";
    if (e.key === "ArrowRight") player.dir = "right";
  }
});
document.addEventListener("keyup", e => {
  if (e.key.startsWith("Arrow")) {
    player.dir = null;
  }
});

function updatePlayer() {
  if (!player.dir) return;

  if (player.dir === "up") player.y--;
  if (player.dir === "down") player.y++;
  if (player.dir === "left") player.x--;
  if (player.dir === "right") player.x++;

  if (player.x < 0 || player.x >= cols || player.y < 0 || player.y >= rows) {
    fillRectangle(player.startX, player.startY, Math.max(0, Math.min(cols - 1, player.x)), Math.max(0, Math.min(rows - 1, player.y)));
    player.x = Math.max(0, Math.min(cols - 1, player.x));
    player.y = Math.max(0, Math.min(rows - 1, player.y));
    player.drawing = false;
    return;
  }

  // Collision check while drawing
  for (let e of enemies) {
    const px = player.x * gridSize + gridSize / 2;
    const py = player.y * gridSize + gridSize / 2;
    if (Math.hypot(e.x - px, e.y - py) < e.r + gridSize / 2) {
      alert("Game Over!");
      location.reload();
    }
  }
}

function fillRectangle(x1, y1, x2, y2) {
  const minX = Math.min(x1, x2);
  const maxX = Math.max(x1, x2);
  const minY = Math.min(y1, y2);
  const maxY = Math.max(y1, y2);
  for (let y = minY; y <= maxY; y++) {
    for (let x = minX; x <= maxX; x++) {
      revealed[y][x] = true;
    }
  }
}

function updateEnemies() {
  for (let e of enemies) {
    e.x += e.vx;
    e.y += e.vy;
    if (e.x < e.r || e.x > canvas.width - e.r) e.vx *= -1;
    if (e.y < e.r || e.y > canvas.height - e.r) e.vy *= -1;
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "black";
  ctx.globalAlpha = 0.9;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.globalAlpha = 1;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (revealed[y][x]) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(x * gridSize, y * gridSize, gridSize, gridSize);
        ctx.clip();
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        ctx.restore();
      }
    }
  }

  if (player.drawing) {
    ctx.fillStyle = "lime";
    const px = player.x * gridSize;
    const py = player.y * gridSize;
    ctx.fillRect(px, py, gridSize, gridSize);
  }

  ctx.fillStyle = "red";
  for (let e of enemies) {
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
    ctx.fill();
  }
}

function loop() {
  updatePlayer();
  updateEnemies();
  draw();
  requestAnimationFrame(loop);
}

img.onload = () => loop();
</script>
</body>
</html>
