
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>True JezzBall Style</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const img = new Image();
img.src = "photo.jpg";

const gridSize = 10;
const cols = Math.floor(canvas.width / gridSize);
const rows = Math.floor(canvas.height / gridSize);

// 0 = black (hidden), 1 = revealed
let map = Array(rows).fill(0).map(() => Array(cols).fill(0));

// Спочатку — по периметру розкрито
for (let x = 0; x < cols; x++) {
  map[0][x] = 1;
  map[rows - 1][x] = 1;
}
for (let y = 0; y < rows; y++) {
  map[y][0] = 1;
  map[y][cols - 1] = 1;
}

let player = { x: 0, y: 0, trail: [], drawing: false };
let dir = null;

const enemies = [
  { x: 200, y: 150, vx: 2, vy: 3, r: 6 },
  { x: 500, y: 100, vx: -3, vy: 2, r: 6 },
];

// клавіші
document.addEventListener("keydown", (e) => {
  if (e.key === "ArrowUp") dir = "up";
  if (e.key === "ArrowDown") dir = "down";
  if (e.key === "ArrowLeft") dir = "left";
  if (e.key === "ArrowRight") dir = "right";
});

function updatePlayer() {
  if (!dir) return;
  let nx = player.x;
  let ny = player.y;

  if (dir === "up") ny--;
  if (dir === "down") ny++;
  if (dir === "left") nx--;
  if (dir === "right") nx++;

  if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) return;

  if (map[ny][nx] === 0 && !player.drawing) {
    player.drawing = true;
    player.trail = [];
  }

  player.x = nx;
  player.y = ny;

  if (player.drawing) {
    player.trail.push({ x: nx, y: ny });
    if (map[ny][nx] === 1) {
      // Закрита фігура — fill
      fillZone(player.trail);
      player.drawing = false;
      player.trail = [];
    }
  }
}

function fillZone(trail) {
  // Проста логіка: беремо весь прямокутник (спрощено)
  const minX = Math.min(...trail.map(p => p.x));
  const maxX = Math.max(...trail.map(p => p.x));
  const minY = Math.min(...trail.map(p => p.y));
  const maxY = Math.max(...trail.map(p => p.y));

  // BFS to detect enclosed area
  const visited = Array(rows).fill(0).map(() => Array(cols).fill(false));

  function floodFill(x, y) {
    let stack = [{ x, y }];
    let touchedEnemy = false;
    let region = [];

    while (stack.length) {
      const { x, y } = stack.pop();
      if (x < 0 || y < 0 || x >= cols || y >= rows) continue;
      if (visited[y][x] || map[y][x] === 1) continue;

      visited[y][x] = true;
      region.push({ x, y });

      // перевіряємо чи ворог у цій зоні
      for (let e of enemies) {
        let ex = Math.floor(e.x / gridSize);
        let ey = Math.floor(e.y / gridSize);
        if (ex === x && ey === y) touchedEnemy = true;
      }

      stack.push({ x: x + 1, y });
      stack.push({ x: x - 1, y });
      stack.push({ x, y: y + 1 });
      stack.push({ x, y: y - 1 });
    }

    if (!touchedEnemy) {
      for (let cell of region) {
        map[cell.y][cell.x] = 1;
      }
    }
  }

  // flood з усіх 4-х кутів
  floodFill(0, 0);
  floodFill(cols - 1, 0);
  floodFill(0, rows - 1);
  floodFill(cols - 1, rows - 1);
}

function updateEnemies() {
  for (let e of enemies) {
    let gx = Math.floor(e.x / gridSize);
    let gy = Math.floor(e.y / gridSize);
    if (map[gy][gx] === 1) {
      // повернути у чорну зону
      e.vx *= -1;
      e.vy *= -1;
    }

    e.x += e.vx;
    e.y += e.vy;

    if (e.x < e.r || e.x > canvas.width - e.r) e.vx *= -1;
    if (e.y < e.r || e.y > canvas.height - e.r) e.vy *= -1;
  }
}

function checkCollision() {
  if (!player.drawing) return;
  const px = player.x * gridSize + gridSize / 2;
  const py = player.y * gridSize + gridSize / 2;
  for (let e of enemies) {
    if (Math.hypot(e.x - px, e.y - py) < e.r + gridSize / 2) {
      alert("Game Over!");
      location.reload();
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw full black
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Reveal parts of image
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (map[y][x] === 1) {
        ctx.drawImage(
          img,
          x * gridSize,
          y * gridSize,
          gridSize,
          gridSize,
          x * gridSize,
          y * gridSize,
          gridSize,
          gridSize
        );
      }
    }
  }

  // Player trail
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < player.trail.length; i++) {
    const p = player.trail[i];
    if (i === 0) ctx.moveTo(p.x * gridSize + gridSize / 2, p.y * gridSize + gridSize / 2);
    else ctx.lineTo(p.x * gridSize + gridSize / 2, p.y * gridSize + gridSize / 2);
  }
  ctx.stroke();

  // Enemies
  ctx.fillStyle = "red";
  for (let e of enemies) {
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
    ctx.fill();
  }

  // Player
  ctx.fillStyle = "lime";
  ctx.beginPath();
  ctx.arc(player.x * gridSize + gridSize / 2, player.y * gridSize + gridSize / 2, 5, 0, Math.PI * 2);
  ctx.fill();
}

function loop() {
  updatePlayer();
  updateEnemies();
  checkCollision();
  draw();
  requestAnimationFrame(loop);
}

img.onload = () => loop();
</script>
</body>
</html>
